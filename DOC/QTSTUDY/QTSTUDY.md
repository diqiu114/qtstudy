Qwidget 基础窗口类：所有窗口，或者控件的父类，QApplication\QDalog都继承自它







main：

​	![image-20221216110419775](C:\Users\DACHI\AppData\Roaming\Typora\typora-user-images\image-20221216110419775.png)



表示窗口的一般都会继承自QObject  





使用对象树：（更方便内存管理）

当窗口构造为对象树的结构时，父对象在释放析构的时候，会自动释放子对象 

创建对象的方式基本上使用new来进行，







信号和槽机制：

信号：各种事件

槽：响应信号的动作







自定义信号

一些规矩：

1. 声明在类头文件的signals域下面
2. void类型的函数，没有返回值
3. 可以有参数，也可以重载
4. 只有声明，没有实现（qt在编译阶段自己添加）
5. 触发信号emit boj->sign(参数。。。)

自定义槽：

1. qt5可以声明在类的任何位置，还可以时静态成员函数、全局函数、lambda表达式
2. void类型的函数，没有返回值
3. 可以有参数，也可以重载
4. 不仅有声明，还得有实现

信号槽扩展：

1. 一个信号可以连接多个槽
   1. 一个信号建立了多个connect，当发生信号发射时，槽函数的调用顺序时随机的
2. 一个槽可以了解多个信号
3. 信号可以连接信号
   1. connect（第一个信号发送者，第一个信号，第二个信号发送者，第二个信号）
4. 信号和槽的参数关系必须满足以下两点
   1. 信号和槽函数的参数类型必须对应
   2. 信号和槽函数的参数个数不需要一致，信号函数参数个数>=槽函数参数个数
      1. hungry(QString)		->		treat()		ok
      2. hungry(QString)        ->		treat(int)    编译出错
5. QTDebug:
   1. QTDebug默认将QString转义输出
   2. 解决方法：
      1. 将QString转成char*

Lambda表达式（匿名函数对象）：

推荐使用形式`[=]() {}`

1. 

```c
int a;
int b;
// 默认传递（传递捕获）参数为const：
[a, b]()
{
    qDebug() << "hello lamabda" << Qt::endl;
    qDebug() << a * b;
};
// = 局部变量全部使用值传递捕获，捕获局部变量包括this
// & 局部变量全部使用应用传递捕获进来
// [=, b]() // 除b为捕获传递，其他都是。。。
// [&a, b]()

```

2. 需要修改值的话，传递捕获中需要&
3. 选项Opt
   1. 常用的是使用mutable声明，可以达到允许修改，值传递的拷贝效果
   2. 

Lamabda在信号和槽中的应用：

```c++
connect(pBnt, &QPushButton::clicked, [=]() {
    qDebug() << a * b << Qt::endl;
});
```

总结：信号和槽：去网上找。。。。。 
